#!/bin/bash
# 说明：
# 多架构支持
# build 过程:
# 1. 查找Dockerfile，默认文件名『Dockerfile』，如果存在『Dockerfile.架构』则优先使用
# 2. 一级目录名为镜像名，TAG: latest，二级目录名为TAG
# 3. 本地build时无论架构镜像:TAG均遵循第二点，但提交时TAG加上架构，如：
#     目录                   本地镜像                     PUSH镜像
#     shadowsocks           jinnlynn/shadowsocks        jinnlynn/shadowsocks:amd64
#     shadowsocks/2.5.6     jinnlynn/shadowsocks:2.5.6  jinnlynn/shadowsocks:2.5.6-amd64
#

# 默认docker user
USER=${DOCKER_USER:-}
[[ -z "$USER" ]] && USER=$(docker info 2>/dev/null | grep Username | awk '{print $2}')
# 构建所有镜像时的优先顺序
ALL_BUILD_PRIORITY=${DOCKER_ALL_BUILD_PRIORITY:-"alpine ubuntu  httpd python python/3 flask php php/fpm node"}


CMD_PUSH=false
CMD_VERBOSE=false
CMD_FORCE=false
CMD_DRY_RUN=false
CMD_QUIET=false
CMD_MANIFEST=false
CMD_BUILD_ARGS=
CMD_BUILD_OPTS=

LIBRARY=library

# macOS下没有 realpath
# REF: https://stackoverflow.com/questions/3572030/bash-script-absolute-path-with-os-x/3572105#3572105
which realpath 1>/dev/null 2>&1 || {
    realpath() {
        [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
    }
}


BASE_DIR=$(realpath $(dirname $0))
ARCH=
SPECIFIED=false

. $BASE_DIR/_scripts/common.sh

is_ignored() {
    local type=$1
    local image=$2
    local suite=$3
    cat $BASE_DIR/.buildignore 2>/dev/null | grep -q -e "^$type,$image\$" -e "^$type,$image:$suite\$"
}

is_build_ignored() {
    is_ignored B $1 $2
}

is_push_ignored() {
    is_ignored P $1 $2
}

get_local_tag() {
    local image=$1
    local suite=$2
    local tag=$image
    [[ -n "$suite" && "$suite" != "latest" ]] && tag="$image:$suite"
    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo $tag
}

get_push_tag() {
    local image=$1
    local suite=$2
    local tag=$LIBRARY
    [[ -z "$suite" || "$suite" == "latest" ]] && tag="$tag:$image-$ARCH" || tag="$tag:$image-$suite-$ARCH"
    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo $tag
}


build() {
    local f

    # 参数为目录时如果存在后缀为架构名的文件，则用其为dockerfile
    [[ -d "$1" ]] && {
        [[ -f "$1/Dockerfile.$ARCH" ]] && f="$1/Dockerfile.$ARCH" || f="$1/Dockerfile"
    } || f="$1"

    [[ ! -f "$f" ]] && {
        echo_red_split "$1 Dockerfile missing."
        return 1
    }

    opts_files=($(ls $(dirname $f)/options* 2>/dev/null))
    if [[ -n "${opts_files[@]}" ]]; then
        for of in ${opts_files[@]}; do
            (
                source $of
                build_s2 $f $of
            )
        done
    else
        build_s2 $f
    fi

}

# 构建镜像
# $1 目录或Dockerfile路径
build_s2() {
    local f=$1
    local of=$2

    local dockerfile=$(basename $f)
    local build_dir=$(dirname $f)
    local image=${build_dir%%\/*}

    [[ -n "$BUILD_TAGS" ]] && suite=($BUILD_TAGS) || suite=(${build_dir##*\/})

    [[ "$suite" == "$build_dir" ]] && suite=("latest")

    local tag=$(get_local_tag $image $suite)

    echo_green "Building $tag for context $build_dir[$dockerfile]"
    echo_green_split
    if is_true $CMD_VERBOSE; then
        echo_green "arch:       $ARCH"
        echo_green "filepath:   $f"
        echo_green "build_dir:  $build_dir"
        echo_green "dockerfile: $dockerfile"
        [[ -n "$of" ]] && \
        echo_green "options:    $of"
        echo_green "image:      $image"
        echo_green "suite:      ${suite:-latest}"
        echo_green "L => S:     $(get_local_tag $image ${suite[0]}) => $(get_push_tag $image ${suite[0]})"
        for s in ${suite[@]:1}; do
            echo_green "            $(get_local_tag $image $s) => $(get_push_tag $image $s)"
        done
        echo_green_split
    fi


    if ! is_true $SPECIFIED; then
        local new_suite=()
        for s in ${suite[@]}; do
            is_build_ignored $image $s && \
                echo_red_split "Build $(get_local_tag $image $s) ignored." || \
                new_suite=(${new_suite[@]} $s)
        done
        if [[ -z "${new_suite[@]}" ]]; then
            return 0
        fi
        suite=(${new_suite[@]})
    fi

    local build_opts="$CMD_BUILD_OPTS $BUILD_OPTIONS"
    is_true $CMD_FORCE && build_opts="$build_opts --no-cache"
    is_true $CMD_QUIET && build_opts="$build_opts --quiet"

    BUILD_ARGS="$BUILD_ARGS $CMD_BUILD_ARGS"
    [[ -n "$BUILD_ARGS" ]] && {
        for a in $BUILD_ARGS; do
            build_opts="$build_opts --build-arg $a"
        done
    }

    for s in ${suite[@]}; do
        build_opts="$build_opts -t $(get_local_tag $image $s)"
    done

    # echo $build_opts
    if run_cmd docker build --rm --force-rm  --network=host $build_opts -f $f $build_dir; then
        echo_green_split "Successfully built $tag with context $image"

        if is_true $CMD_PUSH; then
            for s in ${suite[@]}; do
                push "$image" "$s"
            done
        fi
    else
        echo_red_split "Build $tag with context $image fail."
    fi
    echo
    echo
}

try_run_cmd() {
    local cmd="$1"
    local max=$2

    [[ -z "$max" ]] && max=5

    local n=0
    local run_success=
    until [ $n -ge $max ]; do
        run_cmd "$cmd" && {
            return 0
            break
        }
        echo "Try #$n failed... sleeping for 5 seconds"
        n=$[$n+1]
        sleep 5
    done
    return 1
}

push() {
    local image=$1
    local suite=$2
    local tag=$(get_local_tag $image $suite)
    local push_tag=$(get_push_tag $image $suite)

    local tag_push_desc="$tag => $push_tag"

    if ! is_true $SPECIFIED && is_push_ignored $image $tag; then
        echo_red_split "Push $tag_push_desc ignored."
        return 0
    fi

    echo_green_split "Pushing $tag_push_desc"

    # 标记一个push的临时tag
    run_cmd docker tag $tag $push_tag

    try_run_cmd "docker push $push_tag"
    local push_ret=$?

    # 删除临时标记
    run_cmd docker image rm $push_tag

    [[ $push_ret == 0 ]] && {
        echo_green_split "Successfully push $tag_push_desc"
        if is_true $CMD_MANIFEST; then
            manifest $image $suite
        fi
    } || {
        echo_red_split "Push $tag_push_desc fail."
    }
}

manifest() {
    local image=$1
    local suite=$2
    local tpl=
    local repo=$image:$suite

    [[ "$suite" == "latest" ]] && tpl="$LIBRARY:$image-ARCH" || tpl="$LIBRARY:$image-$suite-ARCH"
    [[ -n "$USER" ]] && {
        tpl="$USER/$tpl"
        repo="$USER/$repo"
    }

    echo_green_split "MAINFEST $tpl => $repo"

    local mt="docker run --rm -ti -v /var/run/docker.sock:/var/run/docker.sock -v /root/.docker:/root/.docker jinnlynn/manifest-tool"

    try_run_cmd "$mt push from-args --platforms linux/amd64,linux/arm --template $tpl --target $repo"
    local manifest_ret=$?

    [[ $push_ret == 0 ]] && {
        echo_green_split "Successfully manifest $tpl => $repo"
    } || {
        echo_red_split "Manifest $tpl => $repo fail."
    }

}

detect_dockerfile() {
    local df=${1:-Dockerfile}
    [[ -d "$df" ]] && df="$df/Dockerfile"
    [[ -n "$(arch_go_mark)" ]] && arch_df="$df.$(arch_go_mark)"
    echo $df
}

build_all() {
    local dirs=$(find_dirs)
    dirs=($ALL_BUILD_PRIORITY ${dirs[@]})
    # 去重
    dirs=($(awk -v RS=' ' '!a[$1]++' <<< ${dirs[@]}))

    for d in ${dirs[@]}; do
        build "$d"
    done
}

build_single() {
    local single=$1
    [[ ! -e "$single" ]] && {
        echo_red_split "$single missing"
        echo
        return 1
    }

    local files=
    [[ -f "$single" ]] && files=($single) || {
        single=${single%/}
        files=$(find_dirs $single 2)
    }

    [[ -z "$files" ]] && {
        echo_red_split "$single Dockerfile missing"
        return 1
    }

    for f in ${files[@]}; do
        build "$f"
    done
}

# 检查参数值
# OPTION ARGUMENT IS_ENABLE_EMPTY
check_param() {
    [[ -z "${2:-}" && -z "$3" ]] && {
        exit_err "选项 $1 需要一个正确的参数值\n"
    }
    [[ "${2:0:1}" = "-" ]] && {
        exit_err "错误的参数值: ${2}"
    }
}

usage() {
    cat <<EOF
USAGE: $0 [OPTIONS] [DOCKERFILE ...]

Options:
  -h, --help        帮助
  -u, --user USER   Docker hub用户名，可为空，不指定默认通过docker info获取
  -x, --proxy       代理，在docker build中添加代理相关参数
  --quiet           安静模式，在docker build中添加--quiet参数
  --build-arg       自定义创建参数，添加到docker build命令中
  -p, --push        构造镜像后推送至镜像库
  -f, --force       强制重建，不使用缓存
  -d, --dry-run     仅输出运行过程
  -v, --verbose     详细输出
EOF
}

# =====
pushd "$BASE_DIR" >/dev/null

while (( ${#} )); do
    case "$1" in
        --user|-u )
            shift 1
            USER=${1:-}
            # 允许USER为空
            check_param "--user|-u" $USER true
            ;;
        --push|-p )
            CMD_PUSH=true
            ;;
        --manifest|-m )
            CMD_PUSH=true
            CMD_MANIFEST=true
            ;;
        --build-arg )
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && CMD_BUILD_ARGS="$CMD_BUILD_ARGS $arg"
            ;;
        --build-opt )
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && CMD_BUILD_OPTS="$CMD_BUILD_OPTS $arg"
            ;;
        --proxy| -x)
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && CMD_BUILD_ARGS="$CMD_BUILD_ARGS http_proxy=$arg https_proxy=$arg"
            ;;
        --force|-f )
            CMD_FORCE=true
            ;;
        --verbose|-v )
            CMD_VERBOSE=true
            ;;
        --dry-run|-d)
            CMD_DRY_RUN=true
            CMD_VERBOSE=true
            ;;
        --quiet|-q)
            CMD_QUIET=true
            ;;
        --help|-h )
            usage
            exit_ok
            ;;
        -* )
            exit_err "错误的选项: $1"
            ;;
        * )
            # 参数结束
            break
            ;;
    esac
    shift 1
done

ARCH=$(arch_go_mark)

CMD_BUILD_ARGS=$(echo $CMD_BUILD_ARGS)

is_true $CMD_VERBOSE && {
    echo
    echo "USER:        $USER"
    echo "ARCH:        $ARCH"
    echo "PUSH:        $CMD_PUSH"
    echo "FORCE:       $CMD_FORCE"
    echo "DRY_RUN:     $CMD_DRY_RUN"
    echo "BUILD_ARGS:  $CMD_BUILD_ARGS"
    echo "FILE/DIR:    $@"
    echo
}

if [[ $# -eq 0 ]]; then
    build_all
else
    SPECIFIED=true
    while [[ $# -gt 0 ]]; do
        build_single $1
        shift $(( $# > 0 ? 1 : 0 ))
    done
fi

exit_ok
