#!/bin/bash

# 默认docker user
USER=${DOCKER_USER:-}
[[ -z "$USER" ]] && USER=$(docker info 2>/dev/null | grep Username | awk '{print $2}')

PUSH=false
VERBOSE=false
FORCE_BUILD=false
DRY_RUN=false
BUILD_ARGS=

BASE_DIR=$(realpath $(dirname $0))
ARCH=
SPECIFIED=false

echo_red() {
    echo -e "\033[31m$@\033[0m"
}

echo_green() {
    echo -e "\033[32m$@\033[0m"
}

echo_split() {
    local start=
    if [[ -n "$@" ]]; then
        echo "================================================="
        echo "\n$@"
        start="\n"
    fi
    echo "$start================================================="
}

echo_err() {
    echo_red $@ >&2
}

exit_err() {
    [[ -n "$@" ]] && echo_err "$@\n"
    usage >&2
    popd >/dev/null
    exit 1
}

exit_ok() {
    [[ -n "$@" ]] && echo_green $@
    popd >/dev/null
    exit 0
}

# 检测arch
detect_arch() {
    ARCH=${ARCH:-$(uname -m)}
}

# arch关系到生成镜像tag
# 默认arch为x86_64, 如果为默认值则将其置空
# arm芯片时将其值设为armhf
arch_mark() {
    case "$ARCH" in
        x86_64)
            echo
            ;;
        armv*)
            echo "armhf"
            ;;
        *)
            echo $ARCH
            ;;
    esac
}

is_ignored() {
    local type=$1
    local image=$2
    local suite=$3
    cat $BASE_DIR/.buildignore 2>/dev/null | grep -q -e "^$type,$image\$" -e "^$type,$image:$suite\$"
}

is_build_ignored() {
    is_ignored B $1 $2
}

is_push_ignored() {
    is_ignored P $1 $2
}

is_true() {
    [[ -z "$1" || "$1" == "false" ]] && return 1 || return 0
}

run_cmd() {
    is_true $DRY_RUN && echo "$@" && return 0
    $@
}

build() {
    local f=$1
    local dockerfile=$(basename $f)
    local build_dir=$(dirname $f)
    local image=${build_dir%%\/*}
    suite=${build_dir##*\/}

    [[ "$suite" == "$build_dir" ]] && suite=""
    suite=${suite:=latest}
    [[ -n "$(arch_mark)" ]] &&  {
        [[ "$suite" == "latest" ]] && suite=$(arch_mark) || suite="$(arch_mark)-$suite"
    }

    local tag="$image:$suite"
    [[ -n "$USER" ]] && tag="$USER/$tag"

    echo_green "Building $tag for context $build_dir[$dockerfile]"
    echo_green $(echo_split)
    if is_true $VERBOSE; then
        echo_green "arch:       $ARCH"
        echo_green "filepath:   $f"
        echo_green "build_dir:  $build_dir"
        echo_green "dockerfile: $dockerfile"
        echo_green "image:      $image"
        echo_green "suite:      $suite"
        echo_green "tag:        $tag"
        echo_green $(echo_split)
    fi

    if ! is_true $SPECIFIED && is_build_ignored $image $suite; then
        echo_red $(echo_split "Build $tag ignored.")
    else
        local build_opt=
        is_true $FORCE_BUILD && build_opt="$build_opt --no-cache"
        [[ -n "$BUILD_ARGS" ]] && {
            for a in $BUILD_ARGS; do
                build_opt="$build_opt --build-arg $a"
            done
        }
        echo $build_opt
        if run_cmd docker build --rm --force-rm --network=host $build_opt -t $tag -f $f $build_dir; then
            echo_green $(echo_split "Successfully built $tag with context $image")
            if is_true $PUSH; then
                push "$image" "$suite"
            fi
        else
            echo_red $(echo_split "Build $tag with context $image fail.")
        fi
    fi
    echo
    echo
}

push() {
    local image=$1
    local suite=$2
    local tag="$image:$suite"

    if ! is_true $SPECIFIED && is_push_ignored $image $tag; then
        echo_red $(echo_split "Push $tag ignored.")
        return 0
    fi

    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo_green $(echo_split "Pushing $tag")
    local n=0
    local pushed=
    until [ $n -ge 5 ]; do
        run_cmd docker push $tag && {
            echo_green $(echo_split "Successfully push $tag")
            pushed=1
            break
        }
        echo "Try #$n failed... sleeping for 5 seconds"
        n=$[$n+1]
        sleep 5
    done
    [[ -z "$pushed" ]] && echo_red $(echo_split "Push $tag fail.")
}

detect_dockerfile() {
    df=${1:-Dockerfile}
    [[ -d "$df" ]] && df="$df/Dockerfile"
    [[ -n "$(arch_mark)" ]] && df="$df.$(arch_mark)"
    echo $df
}

build_all() {
    IFS=$'\n'
    files=$(find . -maxdepth 3 ! -ipath '.\/[~\._]*' -iname $(detect_dockerfile) | sed 's|./||' | sort)
    unset IFS

    for f in ${files[@]}; do
        build "$f"
    done
}

build_single() {
    local single=$1
    [[ ! -e "$single" ]] && {
        echo_red $(echo_split "$single missing")
        echo
        return 1
    }

    local files=
    [[ -f "$single" ]] && files=($single) || {
        single=${single%/}
        IFS=$'\n'
        files=$(find "$single" -maxdepth 2 ! -ipath '.\/[~\._]*' -iname $(detect_dockerfile) | sort)
        unset IFS
    }

    for f in ${files[@]}; do
        build "$f"
    done
}

# 检查参数值
# OPTION ARGUMENT IS_ENABLE_EMPTY
check_param() {
    [[ -z "${2:-}" && -z "$3" ]] && {
        exit_err "选项 $1 需要一个正确的参数值\n"
    }
    [[ "${2:0:1}" = "-" ]] && {
        exit_err "错误的参数值: ${2}"
    }
}

usage() {
    cat <<EOF
USAGE: $0 [OPTIONS] [DOCKERFILE ...]

Options:
  -h, --help        帮助
  -u, --user USER   Docker hub用户名
  -p, --push        构造镜像后推送至镜像库
  -f, --force       强制重建，不使用缓存
  -d, --dry-run     仅输出运行过程
  -v, --verbose     详细输出
EOF
}

# =====
pushd "$BASE_DIR" >/dev/null

while (( ${#} )); do
    case "$1" in
        --user|-u )
            shift 1
            USER=${1:-}
            # 允许USER为空
            check_param "--user|-u" $USER true
            ;;
        --push|-p )
            PUSH=true
            ;;
        --build-arg )
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && BUILD_ARGS="$BUILD_ARGS $arg"
            ;;
        --proxy| -x)
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && BUILD_ARGS="$BUILD_ARGS http_proxy=$arg https_proxy=$arg"
            ;;
        --force|-f )
            FORCE_BUILD=true
            ;;
        --verbose|-v )
            VERBOSE=true
            ;;
        --dry-run|-d)
            DRY_RUN=true
            VERBOSE=true
            ;;
        --help|-h )
            usage
            exit_ok
            ;;
        -* )
            exit_err "错误的选项: $1"
            ;;
        * )
            # 参数结束
            break
            ;;
    esac
    shift 1
done

detect_arch

BUILD_ARGS=$(echo $BUILD_ARGS)

is_true $VERBOSE && {
    echo
    echo "USER:        $USER"
    echo "ARCH:        $ARCH"
    echo "PUSH:        $PUSH"
    echo "FORCE_BUILD: $FORCE_BUILD"
    echo "DRY_RUN:     $DRY_RUN"
    echo "BUILD_ARGS:  $BUILD_ARGS"
    echo "FILE/DIR:    $@"
    echo
}

if [[ $# -eq 0 ]]; then
    build_all
else
    SPECIFIED=true
    while [[ $# -gt 0 ]]; do
        build_single $1
        shift $(( $# > 0 ? 1 : 0 ))
    done
fi

exit_ok
