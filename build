#!/bin/bash
# 说明：
# 多架构支持
# build 过程:
# 1. 查找Dockerfile，默认文件名『Dockerfile』如果存在『Dockerfile.架构』则优先使用
# 2. 一级目录名为镜像名，TAG: latest，二级目录名为TAG
# 3. 本地build时无论架构镜像:TAG均遵循第二点，但提交时TAG加上架构，如：
#     目录                   本地镜像                     PUSH镜像
#     shadowsocks           jinnlynn/shadowsocks        jinnlynn/shadowsocks:amd64
#     shadowsocks/2.5.6     jinnlynn/shadowsocks:2.5.6  jinnlynn/shadowsocks:2.5.6-amd64
#

# 默认docker user
USER=${DOCKER_USER:-}
[[ -z "$USER" ]] && USER=$(docker info 2>/dev/null | grep Username | awk '{print $2}')

PUSH=false
VERBOSE=false
FORCE_BUILD=false
DRY_RUN=false
QUIET=false
BUILD_ARGS=

BASE_DIR=$(realpath $(dirname $0))
ARCH=
SPECIFIED=false

. $BASE_DIR/_scripts/common.sh

is_ignored() {
    local type=$1
    local image=$2
    local suite=$3
    cat $BASE_DIR/.buildignore 2>/dev/null | grep -q -e "^$type,$image\$" -e "^$type,$image:$suite\$"
}

is_build_ignored() {
    is_ignored B $1 $2
}

is_push_ignored() {
    is_ignored P $1 $2
}

get_local_tag() {
    local image=$1
    local suite=$2
    local tag=$image
    [[ -n "$suite" && "$suite" != "latest" ]] && tag="$image:$suite"
    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo $tag
}

get_push_tag() {
    local image=$1
    local suite=$2
    local tag=$image
    [[ -z "$suite" || "$suite" == "latest" ]] && tag="$tag:$ARCH" || tag="$tag:$suite-$ARCH"
    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo $tag
}

# 构建镜像
# $1 默认dockerfile
build() {
    local f=$1

    # 1. 如果存在后缀为架构名的文件，则用其为dockerfile
    [[ -f "$f.$ARCH" ]] && f="$f.$ARCH"

    local dockerfile=$(basename $f)
    local build_dir=$(dirname $f)
    local image=${build_dir%%\/*}
    suite=${build_dir##*\/}

    [[ "$suite" == "$build_dir" ]] && suite=""

    local tag=$(get_local_tag $image $suite)

    echo_green "Building $tag for context $build_dir[$dockerfile]"
    echo_green $(echo_split)
    if is_true $VERBOSE; then
        echo_green "arch:       $ARCH"
        echo_green "filepath:   $f"
        echo_green "build_dir:  $build_dir"
        echo_green "dockerfile: $dockerfile"
        echo_green "image:      $image"
        echo_green "suite:      ${suite:-latest}"
        echo_green "local tag:  $tag"
        echo_green "push tag:   $(get_push_tag $image $suite)"
        echo_green $(echo_split)
    fi

    if ! is_true $SPECIFIED && is_build_ignored $image $suite; then
        echo_red $(echo_split "Build $tag ignored.")
    else
        local build_opt=
        is_true $FORCE_BUILD && build_opt="$build_opt --no-cache"
        is_true $QUIET && build_opt="$build_opt --quiet"
        [[ -n "$BUILD_ARGS" ]] && {
            for a in $BUILD_ARGS; do
                build_opt="$build_opt --build-arg $a"
            done
        }
        # echo $build_opt
        if run_cmd docker build --rm --force-rm --network=host $build_opt -t $tag -f $f $build_dir; then
            echo_green_split "Successfully built $tag with context $image"
            
            if is_true $PUSH; then
                push "$image" "$suite"
            fi
        else
            echo_red $(echo_split "Build $tag with context $image fail.")
        fi
    fi
    echo
    echo
}

push() {
    local image=$1
    local suite=$2
    local tag=$(get_local_tag $image $suite)
    local push_tag=$(get_push_tag $image $suite)

    local tag_push_desc="$tag => $push_tag"

    if ! is_true $SPECIFIED && is_push_ignored $image $tag; then
        echo_red $(echo_split "Push $tag_push_desc ignored.")
        return 0
    fi

    # 标记一个push的临时tag
    run_cmd docker tag $tag $push_tag

    echo_green $(echo_split "Pushing $tag_push_desc")
    local n=0
    local pushed=
    until [ $n -ge 5 ]; do
        run_cmd docker push $push_tag && {
            echo_green $(echo_split "Successfully push $tag_push_desc")
            pushed=1
            break
        }
        echo "Try #$n failed... sleeping for 5 seconds"
        n=$[$n+1]
        sleep 5
    done
    [[ -z "$pushed" ]] && echo_red $(echo_split "Push $tag_push_desc fail.")

    # 删除临时标记
    run_cmd docker image rm $push_tag
}

detect_dockerfile() {
    local df=${1:-Dockerfile}
    [[ -d "$df" ]] && df="$df/Dockerfile"
    [[ -n "$(arch_go_mark)" ]] && arch_df="$df.$(arch_go_mark)"
    echo $df
}

build_all() {
    IFS=$'\n'
    files=$(find . -maxdepth 3 ! -ipath '.\/[~\._]*' -iname "Dockerfile" | sed 's|./||' | sort)
    unset IFS

    for f in ${files[@]}; do
        build "$f"
    done
}

build_single() {
    local single=$1
    [[ ! -e "$single" ]] && {
        echo_red $(echo_split "$single missing")
        echo
        return 1
    }

    local files=
    [[ -f "$single" ]] && files=($single) || {
        single=${single%/}
        IFS=$'\n'
        files=$(find "$single" -maxdepth 2 ! -ipath '.\/[~\._]*' -iname "Dockerfile" | sort)
        unset IFS
    }

    for f in ${files[@]}; do
        build "$f"
    done
}

# 检查参数值
# OPTION ARGUMENT IS_ENABLE_EMPTY
check_param() {
    [[ -z "${2:-}" && -z "$3" ]] && {
        exit_err "选项 $1 需要一个正确的参数值\n"
    }
    [[ "${2:0:1}" = "-" ]] && {
        exit_err "错误的参数值: ${2}"
    }
}

usage() {
    cat <<EOF
USAGE: $0 [OPTIONS] [DOCKERFILE ...]

Options:
  -h, --help        帮助
  -u, --user USER   Docker hub用户名
  -p, --push        构造镜像后推送至镜像库
  -f, --force       强制重建，不使用缓存
  -d, --dry-run     仅输出运行过程
  -v, --verbose     详细输出
EOF
}

# =====
pushd "$BASE_DIR" >/dev/null

while (( ${#} )); do
    case "$1" in
        --user|-u )
            shift 1
            USER=${1:-}
            # 允许USER为空
            check_param "--user|-u" $USER true
            ;;
        --push|-p )
            PUSH=true
            ;;
        --build-arg )
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && BUILD_ARGS="$BUILD_ARGS $arg"
            ;;
        --proxy| -x)
            shift 1
            arg=${1:-}
            [[ -n "$arg" ]] && BUILD_ARGS="$BUILD_ARGS http_proxy=$arg https_proxy=$arg"
            ;;
        --force|-f )
            FORCE_BUILD=true
            ;;
        --verbose|-v )
            VERBOSE=true
            ;;
        --dry-run|-d)
            DRY_RUN=true
            VERBOSE=true
            ;;
        --quiet|-q)
            QUIET=true
            ;;
        --help|-h )
            usage
            exit_ok
            ;;
        -* )
            exit_err "错误的选项: $1"
            ;;
        * )
            # 参数结束
            break
            ;;
    esac
    shift 1
done

ARCH=$(arch_go_mark)

BUILD_ARGS=$(echo $BUILD_ARGS)

is_true $VERBOSE && {
    echo
    echo "USER:        $USER"
    echo "ARCH:        $ARCH"
    echo "PUSH:        $PUSH"
    echo "FORCE_BUILD: $FORCE_BUILD"
    echo "DRY_RUN:     $DRY_RUN"
    echo "BUILD_ARGS:  $BUILD_ARGS"
    echo "FILE/DIR:    $@"
    echo
}

if [[ $# -eq 0 ]]; then
    build_all
else
    SPECIFIED=true
    while [[ $# -gt 0 ]]; do
        build_single $1
        shift $(( $# > 0 ? 1 : 0 ))
    done
fi

exit_ok
