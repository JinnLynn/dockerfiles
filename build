#!/bin/bash

USER=${DOCKER_USER:-}
PUSH=false
VERBOSE=false
FORCE_BUILD=false

BASE_DIR=$(realpath $(dirname $0))
ARCH=

echo_red() {
    echo -e "\033[31m$@\033[0m"
}

echo_green() {
    echo -e "\033[32m$@\033[0m"
}

echo_split() {
    local start=
    if [[ -n "$@" ]]; then
        echo "================================================="
        echo "\n$@"
        start="\n"
    fi
    echo "$start================================================="
}

echo_err() {
    echo_red $@ >&2
}

exit_err() {
    [[ -n "$@" ]] && echo_err "$@\n"
    usage >&2
    popd >/dev/null
    exit 1
}

exit_ok() {
    [[ -n "$@" ]] && echo_green $@
    popd >/dev/null
    exit 0
}

# 检测arch
detect_arch() {
    ARCH=${ARCH:-$(uname -m)}
}

# arch关系到生成镜像tag
# 默认arch为x86_64, 如果为默认值则将其置空
# arm芯片时将其值设为armhf
arch_mark() {
    case "$ARCH" in
        x86_64)
            echo
            ;;
        armv*)
            echo "armhf"
            ;;
        *)
            echo $ARCH
            ;;
    esac
}

is_ignored() {
    local type=$1
    local image=$2
    local tag=$3
    cat $BASE_DIR/.buildignore 2>/dev/null | grep -q -e "^$type,$image\$" -e "^$type,$tag\$"
}

is_build_ignored() {
    is_ignored B $1 $2
}

is_push_ignored() {
    is_ignored P $1 $2
}

is_push() {
    $PUSH
}

is_froce_build() {
    $FORCE_BUILD
}

is_verbose() {
    $VERBOSE
}

build() {
    local f=$1
    local dockerfile=$(basename $f)
    local build_dir=$(dirname $f)
    local image=${build_dir%%\/*}
    suite=${build_dir##*\/}

    [[ "$suite" == "$build_dir" ]] && suite=""
    suite=${suite:=latest}
    [[ -n "$(arch_mark)" ]] &&  {
        [[ "$suite" == "latest" ]] && suite=$(arch_mark) || suite="$(arch_mark)-$suite"
    }

    local tag="$image:$suite"
    [[ -n "$USER" ]] && tag="$USER/$tag"

    echo_green "Building $tag for context $build_dir[$dockerfile]"
    echo_green $(echo_split)
    if is_verbose; then
        echo_green "arch:       $ARCH"
        echo_green "filepath:   $f"
        echo_green "build_dir:  $build_dir"
        echo_green "dockerfile: $dockerfile"
        echo_green "image:      $image"
        echo_green "suite:      $suite"
        echo_green "tag:        $tag"
        echo_green $(echo_split)
    fi

    if is_build_ignored $image $tag; then
        echo_red $(echo_split "Build $tag ignored.")
    else
        local build_opt=
        is_froce_build && build_opt="--no-cache"
        if docker build --rm --force-rm --network=host $build_opt -t $tag -f $f $build_dir; then
            echo_green $(echo_split "Successfully built $tag with context $image")
            if is_push; then
                push "$image" "$suite"
            fi
        else
            echo_red $(echo_split "Build $tag with context $image fail.")
        fi
    fi
    echo
    echo
}

push() {
    local image=$1
    local suite=$2
    local tag="$image:$suite"

    if is_push_ignored $image $tag; then
        echo_red $(echo_split "Push $tag ignored.")
        return 0
    fi

    [[ -n "$USER" ]] && tag="$USER/$tag"
    echo_green $(echo_split "Pushing $tag")
    local n=0
    local pushed=
    until [ $n -ge 5 ]; do
        docker push $tag && {
            echo_green $(echo_split "Successfully push $tag")
            pushed=1
            break
        }
        echo "Try #$n failed... sleeping for 15 seconds"
        n=$[$n+1]
        sleep 5
    done
    [[ -z "$pushed" ]] && echo_red $(echo_split "Push $tag fail.")
}

detect_dockerfile() {
    df=${1:-Dockerfile}
    [[ -d "$df" ]] && df="$df/Dockerfile"
    [[ -n "$(arch_mark)" ]] && df="$df.$(arch_mark)"
    echo $df
}

build_all () {
    local dockerfile=$(detect_dockerfile)
    IFS=$'\n'
    files=$(find . -maxdepth 3 ! -ipath '.\/[~\._]*' -iname $dockerfile | sed 's|./||' | sort)
    unset IFS

    cur=$(pwd)
    for f in ${files[@]}; do
        cd $cur
        build "$f"
    done
}

build_single() {
    local dockerfile=$(detect_dockerfile "$1")

    [[ ! -f "$dockerfile" ]] && {
        echo_red $(echo_split "$1[$dockerfile] missing")
        echo
        return 1
    }

    build "$dockerfile"
}

# 检查参数值
# OPTION ARGUMENT IS_ENABLE_EMPTY
check_param() {
    [[ -z "${2:-}" && -z "$3" ]] && {
        exit_err "选项 $1 需要一个正确的参数值\n"
    }
    [[ "${2:0:1}" = "-" ]] && {
        exit_err "错误的参数值: ${2}"
    }
}

usage() {
    echo -e "USAGE: \n    $0 [--user|-u USER] [--push|-p] [--force|-f] [--verbose|-v] [DOCKERFILE ...]"
}

# =====
pushd "$BASE_DIR" >/dev/null

while (( ${#} )); do
    case "$1" in
        --user|-u )
            shift 1
            USER=${1:-}
            # 允许USER为空
            check_param "--user|-u" $USER true
            ;;
        --push|-p )
            PUSH=true
            ;;
        --force|-f )
            FORCE_BUILD=true
            ;;
        --verbose|-v )
            VERBOSE=true
            ;;
        --help|-h )
            usage
            exit_ok
            ;;
        -* )
            exit_err "错误的选项: $1"
            ;;
        * )
            # 参数结束
            break
            ;;
    esac
    shift 1
done

detect_arch

is_verbose && {
    echo
    echo "USER:        $USER"
    echo "ARCH:        $ARCH"
    echo "PUSH:        $PUSH"
    echo "FORCE_BUILD: $FORCE_BUILD"
    echo "FILE/DIR:    $@"
    echo
}

if [[ $# -eq 0 ]]; then
    build_all
else
    cur=$(pwd)
    while [[ $# -gt 0 ]]; do
        cd $cur
        build_single $1
        shift $(( $# > 0 ? 1 : 0 ))
    done
fi

exit_ok
